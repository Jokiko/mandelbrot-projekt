\documentclass[12pt, onecolumn,notitlepage]{scrartcl}
%\documentclass[handout]{beamer}
%\documentclass[draft]{beamer}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english, ngerman]{babel}
\usepackage{graphics} %Für Bilder

\bibliographystyle{ieeetr}

\begin{document}

\title{Der elementare Synchronisationsmechanismus in Java}

\author{Josua Kirsch, 1293138\\Universität Trier}
\date{Trier den \today}

\newcommand{\define}[1]{\color{darkorange}Definition: \color{black}{#1}\\  } 



\maketitle
\tableofcontents


\section{Einleitung}
Diese Arbeit ist die Ausarbeitung des Vortrag gleichen Titels, welcher am 17.09.2019 im Rahmen des Seminars zum Großen Studienprojekts an der Universität Trier gehalten wurde. Sie fasst kurz den Inhalt des Vortrages zusammen und beschäftigt sich mit den weitergehenden Fragen, was genau \textit{Monitore}, \textit{Semaphore} und \textit{Barrieren} sind und in welcher Beziehung diese zueinander stehen, sowie, welche Rolle Thread-Prioritäten bei dem Schlüsselwort \textit{synchronized} und der Methode wait() spielen. Abschließend erfolgt eine persönliche Reflexion mit Literaturkritik an der Quelle, auf der der Vortrag basierte. \par 
Die Notwendigkeit, Prozesse zu synchronisieren, ergibt sich bereits in einfachen nebenläufigen Programmen aus der Tatsache, dass es beim Zugriff auf gemeinsame Ressourcen zu Wettlaufsituationen, auch Race Conditions genannt, kommen kann. Um solche Fälle zu verhindern, stellt Java nach dem Konzept des wechselseitigen Ausschlusses jedem Objekt einen Sperrmechanismus zur Verfügung. Dieser besteht aus einer impliziten Sperre, deren Zugriff mit der Verwendung des Schlüsselwortes \textit{synchronized} geregelt wird. Besagtes Schlüsselwort kann sowohl auf Instanzmethoden, in welchem Fall die Sperre der Objektinstanz benötigt wird, als auch Klassenmethoden, die die Sperre des Klassenobjektes erfordern, und ganze Blöcke angewendet werden, welche der Sperre eines beliebigen Objektes bedürfen. Somit kann sich innerhalb eines \textit{synchronized} Abschnitts immer nur ein Thread gleichzeitig befinden.\\
Explizit kann innerhalb eines \textit{synchronized} Abschnitts die Sperre mit der Methode wait() freigegeben werden, woraufhin der Thread, der diese Methode aufgerufen hat, in einen Wartezustand verfällt. Aus diesem kann er nur wieder herauskommen, wenn ein anderer Thread in einem Abschnitt, der auf die Sperre des selben Objektes synchronisiert ist, die Methoden notify() oder notifyAll() aufruft. Erstere weckt einen beliebigen Thread wieder auf, letztere weckt sämtliche auf der Sperre wartenden Threads auf, die daraufhin wieder die Sperre erhalten müssen, um an der Stelle fortzufahren, an der sie wait() aufgerufen hatten. Zu bedenken ist, dass bei der Synchronisation mit dem Schlüsselwort \textit{synchronized} auf eine möglichst feine Granularität geachtet werden sollte und dass etwaige Fallstricke wie Deadlocks vermieden werden.

\section{Ergänzung}
\subsection{Monitor, Semaphor \& Barrier}
Das Monitorkonzept wurde Anfang der 1970er Jahre von P. Brinch Hansen und C. A. R. Hoare auf Basis ihrer eigenen vorherigen Arbeiten sowie derer von E. Dijkstra entwickelt.\cite{hansen} Diesem Konzept zufolge sind Monitore ein Feature von Programmiersprachen zur nebenläufigen Programmierung. Ein Monitor arbeitet nach dem Prinzip der Datenkapselung, sodass Daten nur von Prozessen mit Zugriff auf den Monitor gelesen und bearbeitet werden dürfen, wobei es stets immer nur einen Prozess gleichzeitig geben kann, der diesen Zugriff erhält. Somit werden inkonsistente Zustände der Daten durch wechselseitigen Ausschluss verhindert. Darüber hinaus unterstützen Monitore Bedingungssynchronisation, die einem Monitor erlaubt, Threads zu blockieren bis eine bestimme Bedingung erfüllt wurde.\cite{magee} Auf Java übertragen, kann jedes Objekt ein Monitor sein, da durch den Zugriffsmodifikator \textit{private} die Datenkapselung und durch das Schlüsselwort \textit{synchronized} der wechselseitige Ausschluss garantiert werden kann. Da diese Modifikatoren aber nicht zwangsweise verwendet werden müssen, ist ein unsicherer Umgang nicht ausgeschlossen.\cite{joerg} Die Bedingungssynchronisation ist in Java durch die Methoden wait(), notify() und notifyAll() gegeben, wobei ein implizierter Java-Monitor nur über eine einzige Bedingung verfügt. Um eigens definierte Bedingungen zu verwenden, muss das Interface \textit{Condition} importiert werden.\cite{condition} \par
Semaphore als Mechanismus zur Bewältigung von Synchronisationsproblemen wurden 1968 von E. Dijkstra eingeführt. Ein Semaphor \textit{s} ist eine integer Variable, die nur nicht-negative Werte annehmen kann und meist mit der maximalen Zahl der Prozesse, die gleichzeitig die Ressource nutzen können, initialisiert wird. Wurde \textit{s} ein initialer Wert zugewiesen, so kann dieser nur noch durch eine Reservierfunktion down(s) verringert, beziehungsweise durch eine Freigabefunktion up(s) erhöht werden. Wird down(s) aufgerufen, wenn der Zähler auf 0 steht, so wird der aufrufende Thread blockiert und in eine -in der Regel- FIFO-Queue eingereiht. Ist ein Thread mit dem Abarbeiten des parallelen Abschnittes fertig, ruft er up(s) auf, wodurch der Zähler wieder um 1 erhöht wird und der erste Thread in der FIFO-Queue freigegeben wird.\cite{magee} \\
In Java lassen sich binäre Semaphore, also solche, die stets höchstens einen einzigen Thread gleichzeitig in einem Codeabschnitt zulassen, einfach durch Monitore realisieren, indem auf die Methoden wait() und notify() oder aber das Paar wait() und signal() aus dem Interface \textit{Condition} zugegriffen wird. %Letztere Option implementiert den Semaphor genauer, da bei einem Semaphor das \glqq reservieren\grqq{} und \glqq freigeben\grqq{} nicht von ein und dem selben Thread ausgeführt werden muss 
Wie der Monitor selbst basiert der binäre Semaphor somit auf dem Prinzip des wechselseitigen Ausschlusses.\cite{rheinwerk} Für allgemeine Semaphore mit einer Maximalanzahl an Threads ist seit Java 5 die Klasse \textit{Semaphor} deklariert. Die dortigen Implementierungen der Methoden down(s) und up(s) tragen beide das Schlüsswort \textit{synchronized}, womit der resultierende Semaphor auf dem Monitor-Konzept basiert.\cite{semaphorj} \par
Eine Barrier ist ein Punkt im Programm, an dem alle Threads zusammentreffen müssen und ihre Ergebnisse zusammenlegen, bevor sie fortfahren dürfen. Die beteiligten Threads werden dabei nicht beendet, sondern warten lediglich, nachdem sie signalisiert haben, dass sie fertig sind. Eine solche, wiederverwendbare Barrier ist in Java durch die Klasse \textit{CyclicBarrier} realisiert.\cite{rheinwerk} Unabhängig davon lässt sich eine Barrier auch mit Hilfe von Semaphoren implementieren. Für diesen Zweck werden eine Zählvariable und zwei binäre Semaphore benötigt, von denen einer den wechselseitig ausschließenden Zugriff auf die Zählvariable garantiert und der andere, initialisiert mit dem Wert 0, so lang die down(s) aufrufenden Threads blockiert, bis der Wert der Zählvariable die Anzahl an Threads \textit{n} erreicht, die an der Barrier warten sollen. Ist diese Bedingung erfüllt, ruft der \textit{n}-te Thread die Methode up(s) auf und die blockierten Threads können fortfahren. Diese müssen im nächsten Schritt nur noch up(s) aufrufen, um zu garantieren, dass der Thread jweils nach ihnen in der Queue ebenfalls fortschreiten kann.\cite{semaphor}

\subsection{Thread-Prioritäten bei synchronized() und wait()}
Jeder Thread eines Java-Programmes hat eine Thread-Priorität, die aufsteigend in einem Wertebereich von 1 bis 10 liegen kann, wobei 5 der Standardwert ist, wenn die Priorität nicht weiter spezifiziert wird. Unter normalen Umständen hilft die Priorität dem Thread Scheduler, zu bestimmen, welcher Thread als nächstes laufen darf. Daher liegt es nahe, anzunehmen, dass sie auch einen Einfluss auf die Ausführung der Funktionen wait() und notify(), beziehungsweise das Schlüsselwort \textit{synchronized} haben könnten. \\
Ein Blick in die Dokumentation der Klasse \textit{Object} verrät, dass die Methode wait() so spezifiziert ist, dass ein aufrufender Thread in ein Wait Set, also eine Menge, platziert wird, ohne auf irgendwelche Prioritäten Rücksicht zu nehmen. Auch beim Aufruf der Methode notify() spielt die Thread-Priorität keine Rolle, da für die Methode festgelegt ist, dass die Auswahl des zu weckenden Threads vollkommen arbiträr erfolgt und die spezifische Implementierung dieser Auswahl unter Diskretion steht.\cite{object} Somit lässt es sich selbst mit dem Abändern der Thread-Priorität weder beeinflussen noch vorhersagen, welcher Thread beim Aufruf von notify() aus dem Waiting Set entlassen wird. \\
Ähnlich verhält es sich mit dem Schlüsselwort \textit{synchronized} und Threads mit unterschiedlichen Prioritäten. Da die Vergabe der Sperre für den Fall, dass mehrere Threads auf sie warten, nicht fesgelegt ist, lässt sich mit einer erhöhten Thread-Priorität ebenfalls nicht garantieren, dass ein Thread die Sperre vor einem anderen Thread erhält. Jedoch kann der Zugriff auf einen durch \textit{synchronized} geschützten Bereich durch Threads unterschiedlicher Prioritäten zu Komplikationen führen. Das kommt daher, dass die Sperre eines Objektes nur von dem Thread freigeben werden kann, der die Sperre gerade hält. Deswegen kann ein Thread mit einer höheren Priorität als ein anderer, der über die Sperre des Objektes verfügt, blockiert werden und muss warten, bis dieser entweder die Methode wait() aufruft oder das Ende des mit \textit{synchronized} gekennzeichneten Abschnittes erreicht. Kommt nun ein Thread mit einer mittleren Priorität, der aber nicht auf die durch \textit{synchronized} geschützte Ressource zugreifen will und eine lange Aktion durchführt, so wird ihm bevorzugt Rechenzeit zugeteilt. Dadurch kommt der Thread mit der hohen Priorität nicht weiter, weil er indirket durch einen Thread mit niedrigerer Priorität blockiert wird. Dieses Phänomen nennt sich Prioritätsinversion, auch Prioritätsumkehr genannt, und hatte, zum Beispiel, zum Beinaheverlust der Pathfinder-Marssonde geführt. Da für dieses Problem keine optimale Lösung existiert und es durch das nicht vorhersagbare Scheduling der JVM noch verkompliziert wird, ist davon abzuraten, Threads mit unterschiedlichen Prioritäten gemeinsam genutzte Ressourcen verwenden zu lassen.\cite{joerg}

\section{Reflexion}

Diesem Vortrag lag das vierte Kapitel aus dem Buch \textit{Nebenläufige Programmierung in Java. Konzepte und Programmiermodelle für Multicore-Systeme} von Hettel Jörg und Tran Manh Tien zugrunde. Etwas irritiert hat mich, dass der Titel des Kapitels im Plural von \glqq Elementare[n] Synchronisationsmechanismen\grqq{} spricht, jedoch einzig und allein das Schlüsselwort \textit{synchronized} und dazugehörige Fallstricke behandelt. Dennoch bietet es mit anschaulichen Code-Beispielen einen guten Einstieg in die Funktionsweise dieses Mechanismus. Das Monitor-Konzept selbst wird in dem Kapitel jedoch nur ein wenig angeschnitten, sodass die Monitor-Operationen wait(), notify() und notifyAll() in dem Kapitel keinerlei Erwähnung finden. Angesichts der Tatsache, dass mit dem Schlüsselwort \textit{synchronized} das Monitor-Konzept in Java implizit implementiert wird, ist es überraschend, dass die explizite Implementierung in dem Kapitel ausgelassen wurde.\par
Das Seminar des Großen Studienprojekt zum Thema Softwaretechnik, im Rahmen dessen der Vortrag gehalten wurde, handelte von nebenläufigen Prozessen in Java und war damit sowohl eine sinnvolle Auffrischung als auch eine Vertiefung dieser Thematik aus dem Pflichtmodul \textit{Programmierung II}. Da mein Vortrag von dem elementaren Synchronisationsmechanismus und darüber hinaus das Monitor-Konzept in Java handelte, konnte ich bei der Vorbereitung das bereits im besagten Modul erlernte Wissen vertiefen, indem ich mich noch intensiver mit dem Thema beschäftigte als in Programmierung II. Aufgrund der Wichtigkeit und der beschränkten Zeit, mit der sich in einem Modul für fünf Leistungspunkte wie Programmierung II mit nebenläufigen Prozessen beschäftigt werden kann, halte ich ein Seminar zu dieser Thematik für äußerst sinnvoll. 

%\section{Quelle}

%Hettel Jörg, Tran Manh Tien (2016). Nebenläufige Programmierung in Java. Konzepte und Programmiermodelle für Multicore-Systeme. 1. Auflage. S. 51-62
%\\Jeff Magee, Jeff Kramer (1999). Concurrency: State Models \& Java Programs. S. 79-104 

\nocite{*}
\bibliography{esm_bib}


\end{document}

